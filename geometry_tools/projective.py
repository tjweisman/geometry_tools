"""Work with projective space in numerical coordinates.

This module provides abstractions for various objects in projective
geometry (points, lines, subspaces, projective transformations) and
gives a unified framework for acting on these objects by projective
transformations.

The underlying field can be either real or complex (or, in principle,
any data type supported by numpy ndarrays, although this is largely
untested).

Most of the power of the `geometry_tools.projective` module comes from
the fact that it is possible to build "composite" projective objects
out of arrays of subobjects, and then act on the entire composite
object by either a single projective transformation or an array of
projective transformations.

This means you can largely avoid using (slow!) native python loops,
and instead rely on numpy's efficient numerical array computations.

For example, we can build an array of points, and act on all of those
points by a single projective transformation:

```python
import numpy as np
from geometry_tools import projective

# make three points, using coordinates in a standard affine chart
p1 = projective.Point([0, 1.0], chart_index=0)
p2 = projective.Point([1.0, 2.0], chart_index=0)
p3 = projective.Point([0.5, -0.1], chart_index=0)

# package these points together into a single projective object
points = projective.Point([p1, p2, p3])

# get a projective transformation acting on RP^2
transform = projective.Transformation(
    np.array([[5.0, 0.0, 0.0],
              [0.0, 1.0, 0.0],
              [0.0, 0.0, 1/5.0]]), column_vectors=True)

(transform @ points).affine_coords()
```

    array([[ 0.   ,  0.04 ],
           [ 0.2  ,  0.08 ],
           [ 0.1  , -0.004]])


Here is a more complicated (but possibly more useful) example. We can
create an array of points, and turn that into a single polygon
object. Then, we can act on that polygon object by a collection of
projective transformations to get a collection of polygons.

```python

import numpy as np
from geometry_tools import projective, drawtools

# make a polygon out of several points
p1 = projective.Point([0., 0.], chart_index=0)
p2 = projective.Point([1., 0.], chart_index=0)
p3 = projective.Point([1., 1.], chart_index=0)

triangle = projective.Polygon([p1, p2, p3])

# make a diagonalizable projective transformation
aff_transform = projective.Transformation(
    np.array([[1.8, 0.0, 0.0],
              [0.0, 1.0, 0.0],
              [0.0, 0.0, 1/1.8]]),
    column_vectors=True
)

# conjugate this transformation so that its attracting/repelling points
# are at (4, -2) and (4,2)
non_aff = projective.Transformation(
    np.array([[1.0, 0.0, 1.0],
              [4.0, 1.0, 4.0],
              [-2.0, 0.0, 2.0]]),
    column_vectors=True
)
proj_transform = non_aff @ aff_transform @ non_aff.inv()

# construct the cyclic group generated by this projective transformation
rep = projective.ProjectiveRepresentation()
rep["a"] = proj_transform

# get proj_transform^n for |n| < 10, and apply these transformations
# to the triangle
powers = rep.freely_reduced_elements(10)
transformed_triangles = powers @ triangle

# draw a picture of the result
drawing = drawtools.ProjectiveDrawing()
drawing.draw_polygon(triangle)
drawing.draw_polygon(transformed_triangles)

drawing.show()

```

This code produces the image:

![Triangles transformed by many projective transformations](projective_triangles.png)

    """

import itertools
from copy import copy

import numpy as np
from scipy.spatial import ConvexHull

from geometry_tools import utils

if utils.SAGE_AVAILABLE:
    from geometry_tools.utils import sagewrap

from geometry_tools import representation


class GeometryError(Exception):
    """Thrown if there's an attempt to construct a geometric object with
    numerical data that doesn't make sense for that type of object.

    """
    pass

class ProjectiveObject:
    """Represent some object in projective geometry (possibly a composite
    object).

    The underlying data of a projective object is stored as a numpy
    ndarray. The last `unit_ndims` ndims of this array describe a
    *single* instance of this type of object.

    For example, a `Polygon` object has `unit_ndims` equal to 2, since
    a single `Polygon` is represented by an array of shape `(n,d)`,
    where `n` is the number of vertices and `d` is the dimension of
    the underlying vector space. So, a `Polygon` object whose
    underlying array has shape `(5, 6, 4, 3)` represents a 5x6 array
    of quadrilaterals in RP^2 (i.e. the projectivization of R^3).

    """
    def __init__(self, proj_data, aux_data=None, dual_data=None,
                 unit_ndims=1, aux_ndims=0, dual_ndims=0, **kwargs):
        """Parameters
        -----------

        proj_data : ndarray
            underyling data describing this projective object

        aux_data : ndarray
            auxiliary data describing this projective
            object. Auxiliary data is any data which is in principle
            computable from `proj_data`, but is convenient to keep as
            part of the object definition for transformation purposes.

        dual_data : ndarray
            data describing this projective object which transforms
            covariantly, i.e. as a dual vector in projective space.

        unit_ndims : int
            number of ndims of an array representing a "unit" version
            of this object. For example, an object representing a
            single point in hyperbolic space has `unit_ndims` 1, while
            an object representing a line segment has `unit_ndims`
            equal to 2.

        aux_ndims : int
            like `unit_ndims`, but for auxiliary data.

        dual_ndims : int
            like `unit_ndims`, but for covariant (dual) data.

        base_ring : object
            *(requires sage).* Base ring for matrix entries of the
             underlying data for this object. This allows for exact
             computations in projective space (at the cost of
             performance) by supplying a ring that supports exact
             computations. The dtype of the underlying data is
             automatically converted to "object" if this is specified.

        rational_approx : bool
            *(requires sage).* If base_ring is specified, coerce
             floating-point data to a rational approximation before
             converting to the specified ring. This is useful for
             combining computations with floating-point values with
             computations in algebraic number fields.

        """
        self.unit_ndims = unit_ndims
        self.aux_ndims = aux_ndims
        self.dual_ndims = dual_ndims

        try:
            self._construct_from_object(proj_data, **kwargs)
        except TypeError:
            self.set(proj_data, aux_data, dual_data, **kwargs)

    @property
    def dimension(self):
        return self.proj_data.shape[-1] - 1

    def _assert_geometry_valid(self, proj_data):
        if proj_data is None and self.unit_ndims == 0:
            return

        try:
            if proj_data.ndim < self.unit_ndims:
                raise GeometryError(
                    ("{} expects an array with ndim at least {}, got array of shape {}"
                    ).format(
                        self.__class__.__name__, self.unit_ndims, proj_data.shape
                    )
                )
        except AttributeError:
            raise GeometryError(
                ("Data provided to {} must be a numpy array"
                ).format(self.__class__.__name__)
            )

    def _assert_aux_valid(self, aux_data):
        if aux_data is None and self.aux_ndims == 0:
            return

        if aux_data.ndim < self.aux_ndims:
            raise GeometryError( ("{} expects an auxiliary array with"
            " ndim at least {}, got array of shape {}" ).format(
                self.__class__.__name__, self.aux_ndims,
                proj_data.shape ) )

    def _assert_dual_valid(self, dual_data):
        if dual_data is None and self.dual_ndims == 0:
            return

        try:
            if dual_data.ndim < self.dual_ndims:
                raise GeometryError( ("{} expects a dual array with"
                " ndim at least {}, got array of shape {}").format(
                    self.__class__.__name__, self.dual_ndims,
                    dual_data.shape) )
        except AttributeError:
            raise GeometryError(("Dual data provided to {} must be a"
            " numpy array").format(self.__class__.__name__))

    def _assert_data_consistent(self, proj_data, aux_data, dual_data):
        proj_shape = aux_shape = dual_shape = None

        if proj_data is not None:
            proj_shape = proj_data.shape[:-self.unit_ndims]
        if aux_data is not None:
            aux_shape = aux_data.shape[:-self.aux_ndims]
        if dual_data is not None:
            dual_shape = dual_data.shape[:-self.dual_ndims]

        shapes = [shape for shape in [proj_shape, aux_shape, dual_shape]
                  if shape is not None]

        if len(shapes) == 0 or (np.array(shapes) == shapes[0]).all():
            return

        raise GeometryError( ("Mismatched regular/aux/dual data shapes for {}"
            ).self.__class__.__name__)

    def _compute_aux_data(self, proj_data):
        return None

    def _construct_from_object(self, hyp_obj, **kwargs):
        """if we're passed a projective object or an array of projective
        objects, build a new one out of them

        """

        type_error = TypeError(
            "hyp_obj is not a projective object or an iterable of "
            "projective objects."
        )

        try:
            self.set(hyp_obj.proj_data,
                     aux_data=hyp_obj.aux_data,
                     dual_data=hyp_obj.dual_data,
                     **kwargs)
            return
        except AttributeError:
            pass

        unrolled_obj = list(hyp_obj)

        if len(unrolled_obj) == 0:
            raise type_error

        try:
            hyp_array = np.array([obj.proj_data for obj in unrolled_obj])
            aux_array = np.array([obj.aux_data for obj in unrolled_obj])
            dual_array = np.array([obj.dual_data for obj in unrolled_obj])
        except AttributeError:
            raise type_error

        if (hyp_array == None).any():
            hyp_array = None

        if (aux_array == None).any():
            aux_array = None

        if (dual_array == None).any():
            dual_array = None

        try:
            self.set(hyp_array, aux_data=aux_array,
                     dual_data=dual_array, **kwargs)
        except TypeError:
            raise type_error

    @property
    def shape(self):
        """Get the shape of the ndarray of "unit objects" this
        ProjectiveObject represents.

        Returns
        -------
        tuple


        """
        return self.proj_data.shape[:-1 * self.unit_ndims]

    def set(self, proj_data=None, aux_data=None,
            dual_data=None, **kwargs):
        """set the underlying data of the hyperbolic object.

        Subclasses may override this method to give special names to
        portions of the underlying data.

        Parameters
        ----------
        proj_data : ndarray
            underyling data representing this projective object.

        aux_data : ndarray
            underyling auxiliary data for this projective object.

        dual_data : ndarray
            underlying dual data for this projective object.

        base_ring : object
            *(requires sage).* Base ring for matrix entries of the
             underlying data for this object. This allows for exact
             computations in projective space (at the cost of
             performance) by supplying a ring that supports exact
             computations. The dtype of the underlying data is
             automatically converted to "object" if this is specified.

        rational_approx : bool
            *(requires sage).* If base_ring is specified, coerce
             floating-point data to a rational approximation before
             converting to the specified ring. This is useful for
             combining computations with floating-point values with
             computations in algebraic number fields.

        Raises
        ------
        EnvironmentError
            Raised if base_ring is specified but sage is not available
            for import.

        """

        #TODO: add "like" and "dtype" to kwargs

        if proj_data is not None:
            proj_data = np.array(proj_data)

        self._assert_geometry_valid(proj_data)

        if dual_data is not None:
            dual_data = np.array(dual_data)

        self._assert_dual_valid(dual_data)

        if aux_data is None:
            aux_data = self._compute_aux_data(proj_data)

        self._assert_aux_valid(aux_data)

        self.proj_data = proj_data

        if self.aux_ndims > 0:
            self.aux_data = aux_data
        else:
            self.aux_data = None

        if self.dual_ndims > 0:
            self.dual_data = dual_data
        else:
            self.dual_data = None

        self._set_optional(**kwargs)

    def _set_optional(self, base_ring=None, rational_approx=False):
        self.base_ring = None
        if base_ring is not None:
            if not utils.SAGE_AVAILABLE:
                raise EnvironmentError(
                    "Cannot specify base ring unless sage is available"
                )
            self.change_base_ring(base_ring, inplace=True,
                                  rational_approx=rational_approx)

    def flatten_to_unit(self, unit=None):
        """Get a flattened version of the projective object.

        This method reshapes the underlying data of the projective
        object to get a "flat" composite list of objects. For example,
        if called on a Segment object whose underlying array has shape
        (4, 5, 2, 3), this method uses the `unit_ndims` data member to
        interprets this array as an array of segments with shape
        (4,5), and returns a Segment object whose underlying array has
        shape (20, 2, 3).

        Parameters
        ----------

        unit : int
            the number of ndims to treat as a "unit" when flattening
            this object into units.

        """

        aux_unit = unit
        dual_unit = unit
        if unit is None:
            unit = self.unit_ndims
            aux_unit = self.aux_ndims
            dual_unit = self.dual_ndims

        flattened = copy(self)
        new_shape = (-1,) + self.proj_data.shape[-1 * unit:]
        new_proj_data = np.reshape(self.proj_data, new_shape)

        new_aux_data = None
        if self.aux_data is not None:
            new_aux_shape = (-1,) + self.aux_data.shape[-1 * aux_unit:]
            new_aux_data = np.reshape(self.aux_data, new_aux_shape)

        new_dual_data = None
        if self.dual_data is not None:
            new_dual_shape = (-1,) + self.dual_data.shape[-1 * dual_unit:]
            new_dual_data = np.reshape(self.dual_data, new_dual_shape)

        flattened.set(new_proj_data, aux_data=new_aux_data,
                      dual_data=new_dual_data)

        return flattened

    def flatten_to_aux(self):
        return self.flatten_to_unit(self.aux_ndims)

    def __repr__(self):
        return "({}, {})".format(
            self.__class__,
            self.proj_data.__repr__()
        )

    def __str__(self):
        return "{} with data:\n{}".format(
            self.__class__.__name__, self.proj_data.__str__()
        )

    def __getitem__(self, item):
        return self.__class__(self.proj_data[item])

    def __setitem__(self, key, value):
        self.proj_data[key] = self.__class__(value).proj_data

    def __len__(self):
        if len(self.proj_data.shape) == self.unit_ndims:
            raise TypeError("len() of unsized object")

        return len(self.proj_data)

    def astype(self, dtype):
        new_proj = self.proj_data.astype(dtype)
        new_aux = None
        new_dual = None

        if self.aux_data is not None:
            new_aux = self.aux_data.astype(dtype)

        if self.dual_data is not None:
            new_dual = self.dual_data.astype(dtype)


        newobj = ProjectiveObject(new_proj, new_aux, new_dual,
                                  unit_ndims=self.unit_ndims,
                                  aux_ndims=self.aux_ndims,
                                  dual_ndims=self.dual_ndims)

        return self.__class__(newobj)

    def change_base_ring(self, base_ring, inplace=False, **kwargs):
        if not utils.SAGE_AVAILABLE:
            raise EnvironmentError(
                "Cannot change base ring unless sage is available"
            )

        newproj = sagewrap.change_base_ring(self.proj_data, base_ring,
                                            **kwargs)

        newaux = None
        if self.aux_data is not None:
            newaux = sagewrap.change_base_ring(self.aux_data, base_ring,
                                               **kwargs)

        newdual = None
        if self.dual_data is not None:
            newdual = sagewrap.change_base_ring(self.dual_data, base_ring,
                                                **kwargs)

        if not inplace:
            newobj = ProjectiveObject(newproj, newaux, newdual,
                                      unit_ndims=self.unit_ndims,
                                      aux_ndims=self.aux_ndims,
                                      dual_ndims=self.dual_ndims)
            return self.__class__(newobj)

        self.proj_data = newproj
        self.aux_data = newaux
        self.dual_data = newdual

    def projective_coords(self, proj_data=None, **kwargs):
        """Wrapper for ProjectiveObject.set, since underlying coordinates are
        projective."""
        if proj_data is not None:
            self.set(proj_data, **kwargs)

        return self.proj_data

    def affine_coords(self, aff_data=None, chart_index=0, **kwargs):
        """Get or set affine coordinates for this object.

        Parameters
        ----------
        aff_data : ndarray
            if not `None`, coordinate data for this point in an affine
            chart.

        chart_index : int
            index of standard affine chart to get/set coordinates in

        Returns
        -------
        ndarray
            affine coordinates of this Point, in the specified
            standard affine chart.

        """
        if aff_data is not None:
            self.set(projective_coords(aff_data, chart_index=chart_index),
                     **kwargs)

        return affine_coords(self.proj_data, chart_index=chart_index,
                             column_vectors=False)

    @staticmethod
    def _assert_prop_equal(objects, propname):

        if len(objects) == 0:
            return

        properties = np.array([obj.__dict__[propname]
                               for obj in objects])

        if (properties[0] != properties).any():
            raise GeometryError(
                f"{propname} does not match for objects."
            )


    @classmethod
    def combine(cls, to_combine):
        """Construct a new ProjectiveObject of the same type combining the
        data of `self` and `other`.

        Both `self` and `other` will be flattened to unit dimensions
        before combining. If dimensions of the underlying data do not
        match, this will raise an error.

        Parameters
        ----------
        other : ProjectiveObject of the same type as `self`.
            ProjectiveObject to combine with

        Returns
        -------
        ProjectiveObject
            Object of the same type as `self` containing (flattened)
            combined data.

        """
        if len(to_combine) == 0:
            return

        cls._assert_prop_equal(to_combine, "unit_ndims")
        cls._assert_prop_equal(to_combine, "aux_ndims")
        cls._assert_prop_equal(to_combine, "dual_ndims")

        unit_ndims = to_combine[0].unit_ndims
        aux_ndims = to_combine[0].aux_ndims
        dual_ndims = to_combine[0].dual_ndims

        flattened_objs = [
            obj.flatten_to_unit()
            for obj in to_combine
        ]

        # first make a generic ProjectiveObject
        new_data = np.concatenate(
            [obj.proj_data for obj in flattened_objs],
            axis=-(unit_ndims+1)
        )
        new_aux = None
        new_dual = None

        if aux_ndims > 0:
            new_data = np.concatenate(
                [obj.aux_data for obj in flattened_objs],
                axis=-(aux_ndims+1)
            )
            new_aux = np.concatenate([flat_self.aux_data, flat_other.aux_data],
                                     axis=-(self.aux_ndims+1))
        if dual_ndims > 0:
            new_data = np.concatenate(
                [obj.dual_data for obj in flattened_objs],
                axis=-(dual_ndims+1)
            )

        newObj = ProjectiveObject(new_data, new_aux, new_dual,
                                  unit_ndims=unit_ndims,
                                  aux_ndims=aux_ndims,
                                  dual_ndims=dual_ndims)

        # construct an object with the correct type from this underlying data
        return cls(newObj)

    def set_ndims(self, unit_ndims=None, aux_ndims=None, dual_ndims=None):
        if unit_ndims is not None:
            self.unit_ndims = unit_ndims

        if aux_ndims is not None:
            self.aux_ndims = aux_ndims

        if dual_ndims is not None:
            self.dual_ndims = dual_ndims


class Point(ProjectiveObject):
    """A point (or collection of points) in projective space.
    """

    def __init__(self, point, chart_index=None, **kwargs):
        """Parameters
        ----------
        point : ndarray or ProjectiveObject or iterable
            Data to use to construct a Point object. If `point` is an
            `ndarray`, then it is interpreted as data in either
            projective or affine coordinates, depending on whether
            `chart_index` is specified. If `point` is a
            `ProjectiveObject`, then construct a `Point` from the
            underlying data of that object.
        chart_index : int
            if `None` (default), then assume that `point` is data in
            projective coordinates, or a ProjectiveObject. Otherwise,
            interpret `point` as data in affine coordinates, and use
            `chart_index` as the index of the standard affine chart
            those coordinates are in.

        """

        self.unit_ndims = 1
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(point, **kwargs)
            return
        except TypeError:
            pass

        if chart_index is None:
            self.projective_coords(point, **kwargs)
        else:
            self.affine_coords(point, chart_index, **kwargs)

    def in_affine_chart(self, index):
        return self.proj_data[..., index] != 0

class PointPair(Point):
    """A pair of points (or a composite object consisting of a collection
    of pairs of points) in projective space.

    This is mostly useful as an interface for subclasses which provide
    more involved functionality.
    """
    def __init__(self, endpoint1, endpoint2=None, unit_ndims=2,
                 aux_ndims=0, dual_ndims=0, **kwargs):
        """If `endpoint2` is `None`, interpret `endpoint1` as either an
        `ndarray` of shape (2, ..., n) (where n is the dimension of
        the underlying vector space), or else a composite `Point`
        object which can be unpacked into two Points (which may
        themselves be composite).

        If `endpoint2` is given, then both `endpoint1` and `endpoint2`
        can be used to construct `Point` objects, which serve as the
        endpoints for this pair of points.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

        """
        self.set_ndims(unit_ndims, aux_ndims, dual_ndims)

        if endpoint2 is None:
            try:
                self._construct_from_object(endpoint1, **kwargs)
                return
            except (AttributeError, TypeError, GeometryError):
                pass

        self.set_endpoints(endpoint1, endpoint2, **kwargs)

    @property
    def endpoints(self):
        return self.proj_data[..., :2, :]

    def set_endpoints(self, endpoint1, endpoint2=None, **kwargs):
        """Set the endpoints of a segment.

        If `endpoint2` is `None`, expect `endpoint1` to be an array of
        points with shape `(..., 2, n)`. Otherwise, expect `endpoint1`
        and `endpoint2` to be arrays of points with the same shape.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

        """
        if endpoint2 is None:
            self.set(Point(endpoint1).proj_data, **kwargs)
            return

        pt1 = Point(endpoint1)
        pt2 = Point(endpoint2)
        self.set(np.stack([pt1.proj_data, pt2.proj_data], axis=-2), **kwargs)

    def get_endpoints(self):
        """Get a Point representing the endpoints of this pair

        Returns
        -------
        Point
            A composite Point object representing the endpoints of
            this (possibly composite) PointPair

        """
        return Point(self.endpoints)

    def get_end_pair(self):
        """Return a pair of point objects, one for each endpoint

        Returns
        -------
        tuple
            Tuple of the form `(endpoint1, endpoint2)`, where
            `endpoint1` and `endpoint2` are (possibly composite)
            `Point` objects representing the endpoints of this pair

        """
        return (Point(self.endpoints[..., 0, :]),
                Point(self.endpoints[..., 1, :]))

    def endpoint_affine_coords(self, chart_index=0):
        """Get endpoints of this segment in affine coordinates

        Parameters
        ----------
        chart_index : int
            Index of the standard affine chart to take coordinates in

        Returns
        -------
        ndarray
            Affine coordinates of the endpoints of this pair of
            points.

        """
        return self.get_endpoints().affine_coords(chart_index=chart_index)

    def endpoint_projective_coords(self):
        """Get endpoints of this segment in projective coordinates.

        Returns
        -------
        ndarray
            Projective coordinates of the endpoints of this pair of
            points.

        """
        return self.get_endpoints().projective_coords()

class Polygon(Point):
    """A finite-sided polygon in projective space.
    """
    def __init__(self, vertices, aux_data=None, **kwargs):
        """
        Parameters
        ----------
        vertices : Point or ndarray or iterable
            vertices of the polygon, as either an ndarray or a
            composite Point object (provided in the proper order for
            this polygon).

        aux_data : PointPair or ndarray
            Data to use to construct the edges of the polygon. If
            `None`, use the vertex data to compute the edge data.

        """
        ProjectiveObject.__init__(self, vertices, aux_data,
                                  unit_ndims=2, aux_ndims=3,
                                  **kwargs)

    def in_standard_chart(self):
        coord_signs = np.sign(self.projective_coords()[..., 0])
        return np.all(coord_signs == 1, axis=-1) | np.all(coord_signs == -1, axis=-1)

    @property
    def vertices(self):
        return self.proj_data

    @property
    def edges(self):
        return self.aux_data

    def _compute_aux_data(self, proj_data):
        segments = PointPair(proj_data, np.roll(proj_data, -1, axis=-2))
        return segments.proj_data

    def get_edges(self):
        """Get the edges of this polygon

        Returns
        -------
        PointPair
            Edges of this polygon, as a composite PointPair object.

        """
        return PointPair(self.edges)

    def get_vertices(self):
        """Get the vertices of the polygon.

        Returns
        -------
        Point
            Vertices of this polygon, as a composite Point object.

        """
        return Point(self.proj_data)

class Simplex(Point):
    """An n-simplex in projective space.
    """
    def __init__(self, vertices, **kwargs):
        """
        Parameters
        ----------
        vertices : ProjectiveObject or ndarray
            Data giving the vertices of the simplex (or a composite of
            several simplices)

        """
        ProjectiveObject.__init__(self, vertices, unit_ndims=2, **kwargs)

    @property
    def n(self):
        """Number of vertices in the simplex.
        """
        return self.proj_data.shape[-2]

    def skeleton(self, k):
        """Get the k-skeleton of this simplex, as a composite Simplex.

        Parameters
        ----------
        k : int
            Dimension of the skeleton to get

        Returns
        -------
        Simplex
            Composite Simplex object, with one subobject for each
            k-dimensional face of this simplex.

        """
        indices = list(itertools.combinations(range(self.n), k))
        return Simplex(self.proj_data[..., indices, :])

    def faces(self):
        """Get the codimension-1 faces of the simplex.

        Alias for self.skeleton(n - 1), where n is the number of
        vertices in this simplex.

        """
        return self.skeleton(self.n - 1)

    def edges(self):
        """Get the edges of the simplex.

        Alias for PointPair(self.skeleton(2))."""
        return PointPair(self.skeleton(2))

    def vertices(self):
        """Get the vertices of this simplex as a Point object.
        """
        return Point(self)

class Subspace(ProjectiveObject):
    """A projective subspace (or composite object consisting of projective
    subspaces with the same dimension)

    """
    def __init__(self, proj_data, **kwargs):
        """
        Parameters
        ----------
        proj_data : ProjectiveObject or ndarray
            data specifying a spanning set for this projective
            subspace. These are presumed to be a set of linearly
            independent vectors.

        """
        ProjectiveObject.__init__(self, proj_data, unit_ndims=2, **kwargs)

    @property
    def n(self):
        """Dimension of the vector space underlying this subspace.
        """
        return self.proj_data.shape[-2]

    def intersect(self, other, broadcast="elementwise"):
        """Get a subspace giving the intersection of self with other.

        All intersections are presumed to be transverse. So, the
        dimension of the underlying vector space of the returned
        subspace is always: (dimension of self) + (dimension of other)
        - (dimension of ambient vector space).

        Parameters
        ----------
        other : Subspace or ndarray
            Subspace to intersect with.

        broadcast : {"elementwise", "pairwise"}
            If "elementwise" (the default), and self/other are
            composite objects, then compute the element-by-element
            intersection. For this to work properly, self and other
            must have the same shape (as composite objects).

            If "pairwise", compute intersections between every
            subspace in self and every subspace in other. If self has
            a (composite) shape (N1, N2, ... Ni) and other has
            composite shape (M1, M2, ..., Mj), then the returned
            object has composite shape (N1, N2, ... Ni, M1, M2, ...,
            Mj).

        Returns
        -------
        Subspace
            Intersection of self and other.

        """

        other_obj = Subspace(other)

        if broadcast == "elementwise":
            p1, p2 = self.proj_data, other_obj.proj_data
        elif broadcast == "pairwise":
            p1, p2 = utils.broadcast_match(self.proj_data,
                                          other_obj.proj_data, 2)
        else:
            raise ValueError(f"Unrecognized broadcast rule: '{broadcast}'")

        spans = np.concatenate((p1, p2), axis=-2)

        kernel_coeffs = utils.kernel(spans.swapaxes(-1, -2))
        subspace_coeffs = kernel_coeffs[..., :self.n, :].swapaxes(-1, -2)

        return Subspace(utils.matrix_product(subspace_coeffs, p1))

class ConvexPolygon(Polygon):
    """A finite-sided convex polygon in projective space.
    """

    def __init__(self, vertices, aux_data=None, dual_data=None, **kwargs):
        r"""When providing point data for this polygon, non-extreme points
        (i.e. points in the interior of the convex hull) are
        discarded. To determine which points lie in the interior of
        the convex hull, the constructor either:

        - uses the provided `dual_data` to determine an affine
          chart in which the convex polygon lies (this chart is
          the complement of the hyperplane specified in
          `dual_data`), or

        - interprets the projective coordinates of the provided points
          as preferred lifts of those points in \(\mathbb{R}^n\), and
          computes an affine chart containing the projectivization of
          the convex hull of those lifts.

        Parameters
        ----------
        vertices : Point or ndarray
            points contained in this polygon
        aux_data : PointPair or None
            Data to construct the edges of this polygon. If `None`,
            use vertex data to construct edge data.
        dual_data : ProjectiveObject
            Dual vector specifying an affine chart containing every
            point in this convex polygon. If `None`, then compute a
            dual vector using lifts of the vertex data.

    """

        ProjectiveObject.__init__(self, vertices, aux_data=aux_data,
                                  dual_data=dual_data, unit_ndims=2,
                                  aux_ndims=3, dual_ndims=1, **kwargs)
    def add_points(self, points, in_place=False):
        """Add points to an existing convex polygon.

        Parameters
        ----------
        points : Point or ndarray
            Points to add to the convex polygon. Redundant points
            (lying in the interior of the convex hull) will be
            discarded.
        in_place : bool
            if `True`, modify this convex polygon object in-place
            instead of returning a new one.

        Raises
        ------
        GeometryError
            Raised if points are added to a composite ConvexPolygon
            (currently unsupported)

        Returns
        -------
        ConvexPolygon
            if `in_place` is `False`, return a modified ConvexPolygon
            object with the new points added.

        """

        if len(self.proj_data.shape) > 2:
            raise GeometryError(
                "Adding new points to a composite ConvexPolygon object is currently"
                " unsupported."
            )

        to_add = Point(points)
        new_data = np.concatenate((self.proj_data, to_add.proj_data), axis=-2)

        if in_place:
            self.set(new_data)
            return

        new_poly = ConvexPolygon(new_data)
        return new_poly

    def _convexify(self):
        if len(self.proj_data.shape) > 2:
            raise GeometryError(
                "Cannot auto-convexify a composite ConvexPolygon object."
            )

        dim = self.proj_data.shape[-1]
        self.dual_data = utils.find_positive_functional(self.proj_data)

        to_std_aff = utils.invert(utils.find_isometry(utils.identity(dim),
                                                       self.dual_data))

        standardized_coords = Point(
            self.proj_data @ to_std_aff
        ).affine_coords(chart_index=0)

        vertex_indices = ConvexHull(standardized_coords).vertices

        self.proj_data = self.proj_data[vertex_indices]
        self.aux_data = self._compute_aux_data(self.proj_data)

    def set(self, proj_data, aux_data=None, dual_data=None, **kwargs):
        ProjectiveObject.set(self, proj_data, aux_data, dual_data, **kwargs)
        if dual_data is None:
            self._convexify()

class Transformation(ProjectiveObject):
    """A projective transformation (or a composite object consisting of a
    collection of projective transformations).
    """
    def __init__(self, proj_data, column_vectors=False, **kwargs):
        """By default, the underlying data for a projective
        transformation is a *row matrix* (or an ndarray of row
        matrices), acting on vectors on the *right*.

        Parameters
        ----------
        proj_data : ProjectiveObject or ndarray
            Data to use to construct a projective transformation (or
            array of projective transformations).
        column_vectors : bool
            If `True`, interpret proj_data as a *column matrix* acting
            on the left. Otherwise proj_data gives a *row matrix*.
        """
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(proj_data, **kwargs)
        except TypeError:
            if column_vectors:
                self.set(proj_data.swapaxes(-1,-2), **kwargs)
            else:
                self.set(proj_data, **kwargs)

    def _assert_geometry_valid(self, proj_data):
        ProjectiveObject._assert_geometry_valid(self, proj_data)
        if (len(proj_data.shape) < 2 or
            proj_data.shape[-2] != proj_data.shape[-1]):
            raise GeometryError(
                ("Projective transformation must be ndarray of n x n"
                 " matrices, got array with shape {}").format(
                     proj_data.shape))

    @property
    def matrix(self):
        return self.proj_data

    def _apply_to_data(self, proj_data, broadcast, unit_ndims=1, dual=False):
        matrix = self.matrix
        if dual:
            matrix = utils.invert(matrix).swapaxes(-1, -2)
        return utils.matrix_product(proj_data,
                                    matrix,
                                    unit_ndims, self.unit_ndims,
                                    broadcast=broadcast)

    def apply(self, proj_obj, broadcast="elementwise"):
        """Apply this transformation to another object in projective space.

        Parameters
        ----------
        proj_obj : ProjectiveObject or ndarray
            Projective object to apply this transformation to. This object
            may be composite.
        broadcast : string
            Broadcasting behavior for applying composite
            transformation objects. If "elementwise", then the shape
            of this (composite) transformation object and the shape of
            the (composite) object to apply transformations to need to
            be broadcastable. If "pairwise", then apply every element
            of this (composite) transformation object to every element
            of the target object (i.e. take an outer product).

        Returns
        -------
        ProjectiveObject
            Transformed (possibly composite) projective object. The
            type of this object is the same type as the original
            (untransformed) object. If the original object was
            provided as an ndarray, then the returned object has type
            ProjectiveObject.

        """
        new_obj = copy(proj_obj)

        try:
            proj_data = new_obj.proj_data
            proj_product = None
            if proj_data is not None:
                proj_product = self._apply_to_data(new_obj.proj_data, broadcast,
                                                   new_obj.unit_ndims)

            aux_data = new_obj.aux_data
            aux_product = None
            if aux_data is not None:
                aux_product = self._apply_to_data(new_obj.aux_data, broadcast,
                                                  new_obj.aux_ndims)

            dual_data = new_obj.dual_data
            dual_product = None
            if dual_data is not None:
                dual_product = self._apply_to_data(new_obj.dual_data, broadcast,
                                                   new_obj.dual_ndims)

            new_obj.set(proj_data=proj_product,
                        aux_data=aux_product,
                        dual_data=dual_product)

            return new_obj
        except AttributeError:
            pass

        #otherwise, it's an array of vectors which we'll interpret as
        #some kind of hyperbolic object
        product = self._apply_to_data(proj_obj, broadcast)
        return self._data_to_object(product)

    def eigenvector(self, eigenvalue=None, compute_exact=False):
        """Get a point corresponding to an eigenvector with the given
        eigenvalue.

        Parameters
        ----------
        eigenvalue : float
            Eigenvalue for the returned eigenvector. If None, return
            an arbitrary eigenvector.

        compute_exact : bool
            If True, and sage is available, then (if possible) use
            sage matrix functions to compute exact entries for the
            eigenvector found. If sage is not available, or the
            underlying data of this transformation does not support
            exact computation, then this parameter has no effect.

        Returns
        -------
        Point
            Point object in projective space giving an eigenvector for
            the given eigenvalue. The projective coordinates of this
            point will be degenerate (i.e. zero) if no nonzero
            eigenvector with this eigenvalue exists.

    """
        eigvals, eigvecs = utils.eig(self.proj_data.swapaxes(-1, -2),
                                     compute_exact=compute_exact)
        eigvec_coords = utils.zeros(self.proj_data.shape[:-1])

        ic = np.ones_like(eigvals)
        if eigenvalue is not None:
            ic = np.isclose(eigvals, eigenvalue)

        where_ic = ic.nonzero()

        if len(where_ic) == 1:
            if len(where_ic[0]) > 0:
                eigvec_coords = (eigvecs.T)[where_ic[0][0]]
                return Point(eigvec_coords)
            raise GeometryError(
                ("Transformation does not have {} as an approximate eigenvalue").format(
                    eigenvalue)
            )

        unind, indind = np.unique(np.array(where_ic[:-1]).T,
                                  return_index=True, axis=0)

        eigvec_coords[tuple([*unind.T])] = eigvecs.swapaxes(-1,-2)[
            tuple([*(np.array(where_ic).T)[indind].T])
        ]

        return Point(eigvec_coords)


    def _data_to_object(self, data):
        return ProjectiveObject(data)

    def inv(self):
        """Get the inverse of this transformation.

        Returns
        -------
        ProjectiveTransformation
            Inverse of this transformation.
        """
        return self.__class__(utils.invert(self.matrix))

    def __matmul__(self, other):
        return self.apply(other)

class ProjectiveRepresentation(representation.WrappedRepresentation):
    """A representation (of a free group) lying in PGL(V). Passing words
    (in the generators) to this representation yields `Transformation`
    objects.
    """

    @staticmethod
    def wrap_func(numpy_matrix):
        return Transformation(numpy_matrix, column_vectors=True)

    @staticmethod
    def unwrap_func(wrapped_matrix):
        return wrapped_matrix.matrix.T

    @staticmethod
    def array_wrap_func(numpy_array):
        return Transformation(numpy_array, column_vectors=True)

    def transformations(self, words):
        """Get a composite transformation, representing a sequence of words in
        the generators for this representation.

        Parameters
        ----------
        words : iterable of strings
            Sequence of words to apply this representation to.

        Returns
        -------
        Transformation
            Composite transformation object containing one
            transformation for each word in `words`.

        """
        return self.elements(words)

def hyperplane_coordinate_transform(normal):
    r"""Find an orthogonal matrix taking the affine chart \(\{\vec{x} :
       \vec{x} \cdot \vec{n} \ne 0\}\) to the standard affine chart
       \(\{\vec{x} = (x_0, \ldots, x_n) : x_0 \ne 0\}\).

    Parameters
    ----------
    normal : array
        The vector \(\vec{n}\), normal to some hyperplane in R^n.

    Returns
    -------
    Transformation
        Projective transformation (orthogonal in the standard inner
        product on R^n) taking the desired affine chart to the
        standard chart with index 0.

    """
    mat = utils.find_definite_isometry(normal)
    return Transformation(mat, column_vectors=True).inv()

def affine_coords(points, chart_index=None, column_vectors=False):
    """Get affine coordinates for an array of points in projective space
    in one of the standard affine charts.

    Parameters
    ----------
    points: ndarray
        `ndarray` of points in projective space. the last dimension is
        assumed to be the same as the dimension of the underlying
        vector space.

    chart_index: int
        which of the n affine charts to take coordinates in. If
        `None`, determine the chart automatically.

    column_vectors: bool
        if `True`, interpret the second-to-last index as the dimension
        of the underlying vector space.

    Returns
    -------
    ndarray
        If chart_index is specified, return an array of points in
        affine coordinates in that chart. Otherwise, return a tuple
        `(affine, chart_index)`, where `chart_index` is the affine
        chart used.

        If `column_vectors` is `False` (the default), then the last
        index of the returned array is the dimension of the affine
        space. Otherwise, the second-to-last index is the dimension of
        affine space.

    """
    apoints = np.array(points)

    if column_vectors:
        apoints = apoints.swapaxes(-1, -2)

    _chart_index = chart_index

    #auto-determine chart
    if chart_index is None:
        _chart_index = np.argmax(
            np.min(np.abs(apoints), axis=tuple(range(len(apoints.shape) - 1)))
        )

    if (apoints[..., _chart_index].astype('float64') == 0).any():
        if chart_index is not None:
            raise GeometryError(
                "points don't lie in the specified affine chart"
            )
        else:
            raise GeometryError(
                "points don't lie in any standard affine chart"
            )

    affine = np.delete(
        (apoints.T / apoints.T[_chart_index]).T,
        _chart_index, axis=-1
    )

    if column_vectors:
        affine = affine.swapaxes(-1, -2)

    if chart_index is None:
        return (affine, _chart_index)
    else:
        return affine

def projective_coords(points, chart_index=0, column_vectors=False):
    """Get projective coordinates for points in affine space

    Parameters
    ----------
    points : ndarray or sequence
        Points in affine coordinates. The last dimension of the array
        is the dimension of affine space.

    chart_index: int
        Index of the affine chart we assume these points are lying in

    column_vectors: bool
        If `True`, interpret the second-to-last index as the dimension
        of affine space.

    Returns
    -------
    ndarray
        Projective coordinates of the given points. The last dimension
        of the array is the dimension of the underlying vector space
        (or the second-to-last dimension, if `column_vectors` is
        `True`).

    """
    coords = np.array(points)

    if column_vectors:
        coords = coords.swapaxes(-1, -2)

    result = utils.zeros(coords.shape[:-1] + (coords.shape[-1] + 1,),
                         like=coords)

    indices = np.arange(coords.shape[-1])
    indices[chart_index:] += 1

    result[..., indices] = coords

    # wrap literal numerical 1 (for sage)
    one = utils.number(1, like=coords)
    result[..., chart_index] = one

    if column_vectors:
        result = result.swapaxes(-1, -2)

    return result

def identity(dimension):
    """Get the identity projective transformation.

    Parameters
    ----------
    dimension : int
        Dimension of the projective space to act on.

    Returns
    -------
    Transformation
        The identity map on RP^n, where n = `dimension`.

    """

    return Transformation(np.identity(dimension + 1))

def affine_linear_map(linear_map, chart_index=0, column_vectors=True):
    """Get a projective transformation restricting to a linear map on a
       standard affine chart.

    Parameters
    ----------
    linear_map : ndarray
        A linear map giving an affine transformation on a standard
        affine chart

    chart_index : int
        Index of the standard affine chart where this projective
        transformation acts

    column_vectors :
        It `True`, interpret `linear_map` as a matrix acting on column
        vectors (on the left). Otherwise, `linear_map` acts on row
        vectors (on the right).

    Returns
    -------
    Transformation
        Projective transformation preserving a standard affine chart
        and acting by a linear map on that affine space (i.e. fixing a
        point in that affine space).

    """
    h, w = linear_map.shape

    tf_mat = np.block(
        [[linear_map[:chart_index, :chart_index],
          np.zeros((chart_index, 1)), linear_map[:chart_index, chart_index:]],
         [np.zeros((1, chart_index)), 1., np.zeros((1, w - chart_index))],
         [linear_map[chart_index:, :chart_index],
          np.zeros((h - chart_index, 1)), linear_map[chart_index:, chart_index:]]])

    return Transformation(tf_mat, column_vectors=column_vectors)

def affine_translation(translation, chart_index=0):
    """Get a translation in a standard affine chart.

    Parameters
    ----------
    translation : ndarray
        vector to translate along in affine space
    chart_index : int
        index of the standard affine chart this translation acts on

    Returns
    -------
    Transformation
        Projective transformation preserving a standard affine chart
        and acting by an affine translation in that affine space.

    """
    tf = np.identity(len(translation) + 1)
    tf[chart_index, :chart_index] = translation[:chart_index]
    tf[chart_index, chart_index + 1:] = translation[chart_index:]

    return Transformation(tf, column_vectors=False)
